name: Reusable Tauri Build

on:
  workflow_call:
    inputs:
      tag:
        description: "Release tag to upload assets to"
        required: true
        type: string
      ref:
        description: "Git ref to checkout (optional)"
        required: false
        type: string
      version:
        description: "Version for filenames (optional)"
        required: false
        type: string
      cache_key_suffix:
        description: "Suffix for rust-cache shared key"
        required: false
        type: string
        default: "build"
    secrets:
      TAURI_SIGNING_PRIVATE_KEY:
        required: true
      TAURI_SIGNING_PRIVATE_KEY_PASSWORD:
        required: true

permissions:
  contents: write

env:
  CARGO_TERM_COLOR: always

jobs:
  build:
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: macos-latest
            arch: aarch64
            runs-on: macos-latest
            target: aarch64-apple-darwin
          - platform: macos-latest
            arch: x86_64
            runs-on: macos-latest
            target: x86_64-apple-darwin
          - platform: ubuntu-22.04
            arch: x86_64
            runs-on: ubuntu-22.04
            target: x86_64-unknown-linux-gnu
          - platform: windows-latest
            arch: x86_64
            runs-on: windows-latest
            target: x86_64-pc-windows-msvc

    runs-on: ${{ matrix.runs-on }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.ref != '' && inputs.ref || github.ref }}

      - name: Install dependencies (ubuntu only)
        if: matrix.platform == 'ubuntu-22.04'
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            libgtk-3-dev \
            libwebkit2gtk-4.1-dev \
            libappindicator3-dev \
            librsvg2-dev \
            patchelf

      - name: Rust setup
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Rust cache
        uses: swatinem/rust-cache@v2
        with:
          workspaces: './src-tauri -> target'
          cache-on-failure: true
          cache-targets: true
          shared-key: tauri-${{ matrix.platform }}-${{ inputs.cache_key_suffix }}

      - name: Sync node version and setup cache
        uses: actions/setup-node@v4
        with:
          node-version: 'lts/*'
          cache: 'npm'

      - name: Install frontend dependencies
        run: npm ci

      - name: Clean previous bundles
        shell: bash
        run: |
          rm -rf "src-tauri/target/${{ matrix.target }}/release/bundle" || true

      - name: Build with Tauri
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
          RUST_LOG: debug
        shell: bash
        run: |
          echo "Building for target ${{ matrix.target }}..."
          npm run tauri:build -- --target ${{ matrix.target }} --verbose

      - name: Process and rename artifacts
        shell: bash
        run: |
          echo "=== Starting file rename process ==="
          BUNDLE_DIR="src-tauri/target/${{ matrix.target }}/release/bundle"
          PLATFORM="${{ matrix.platform }}"
          ARCH="${{ matrix.arch }}"
          VERSION="${{ inputs.version }}"

          rename_with_sig() {
            local file="$1"
            local new_name="$2"

            if [ ! -f "$file" ] || [ "$file" = "$new_name" ]; then
              return 0
            fi

            mv "$file" "$new_name"
            if [ -f "${file}.sig" ]; then
              mv "${file}.sig" "${new_name}.sig"
            fi
          }

          if [ ! -d "$BUNDLE_DIR" ]; then
            echo "❌ Bundle directory not found: $BUNDLE_DIR"
            echo "Searching for bundle directories:"
            find src-tauri/target -type d -name "bundle" 2>/dev/null || true
            exit 1
          fi

          if [ -n "$VERSION" ]; then
            AG_NAME_MID="_${VERSION}"
            AG_LINUX_MID="_${VERSION}"
          else
            AG_NAME_MID=""
            AG_LINUX_MID=""
          fi

          # macOS
          if [ "$PLATFORM" = "macos-latest" ]; then
            if [ -d "$BUNDLE_DIR/dmg" ]; then
              (
                cd "$BUNDLE_DIR/dmg/"
                for file in *.dmg; do
                  if [ -f "$file" ]; then
                    rename_with_sig "$file" "Antigravity.Agent${AG_NAME_MID}_${ARCH}.dmg"
                  fi
                done
              )
            fi

            # updater bundle (required for macOS auto-update)
            if [ -d "$BUNDLE_DIR/macos" ]; then
              (
                cd "$BUNDLE_DIR/macos/"
                for file in *.app.tar.gz; do
                  if [ -f "$file" ]; then
                    rename_with_sig "$file" "Antigravity.Agent${AG_NAME_MID}_${ARCH}.app.tar.gz"
                  fi
                done
              )
            fi
          fi

          # Windows
          if [ "$PLATFORM" = "windows-latest" ]; then
            if [ -d "$BUNDLE_DIR/msi" ]; then
              (
                cd "$BUNDLE_DIR/msi/"
                for file in *.msi *.msi.zip; do
                  if [ -f "$file" ]; then
                    if echo "$file" | grep -q "\\.msi\\.zip$"; then
                      rename_with_sig "$file" "Antigravity.Agent${AG_NAME_MID}_x64-setup.msi.zip"
                    else
                      rename_with_sig "$file" "Antigravity.Agent${AG_NAME_MID}_x64-setup.msi"
                    fi
                  fi
                done
              )
            fi

            if [ -d "$BUNDLE_DIR/nsis" ]; then
              (
                cd "$BUNDLE_DIR/nsis/"
                for file in *.exe *.nsis.zip; do
                  if [ -f "$file" ]; then
                    if echo "$file" | grep -q "\\.nsis\\.zip$"; then
                      rename_with_sig "$file" "Antigravity.Agent${AG_NAME_MID}_x64-setup.nsis.zip"
                    else
                      rename_with_sig "$file" "Antigravity.Agent${AG_NAME_MID}_x64-setup.exe"
                    fi
                  fi
                done
              )
            fi
          fi

          # Linux
          if [ "$PLATFORM" = "ubuntu-22.04" ]; then
            if [ -d "$BUNDLE_DIR/deb" ]; then
              (
                cd "$BUNDLE_DIR/deb/"
                for file in *.deb; do
                  if [ -f "$file" ]; then
                    rename_with_sig "$file" "antigravity-agent${AG_LINUX_MID}_amd64.deb"
                  fi
                done
              )
            fi
          fi

      - name: Create Windows Portable Version
        if: matrix.platform == 'windows-latest'
        shell: pwsh
        run: |
          Write-Host "=== Creating Windows Portable Version ==="

          $exePath = "src-tauri\target\${{ matrix.target }}\release\antigravity-agent.exe"
          $outputDir = "portable-package"
          $bundleDir = "src-tauri\target\${{ matrix.target }}\release\bundle"
          $zipPath = "$bundleDir\Antigravity-Agent-${{ matrix.arch }}-Portable.zip"

          if (!(Test-Path $bundleDir)) {
            New-Item -ItemType Directory -Force -Path $bundleDir | Out-Null
          }

          if (Test-Path $exePath) {
            New-Item -ItemType Directory -Force -Path $outputDir | Out-Null
            Copy-Item $exePath "$outputDir\Antigravity.Agent.exe"
            Compress-Archive -Path "$outputDir\*" -DestinationPath $zipPath -Force
            Remove-Item -Recurse -Force $outputDir
          } else {
            Write-Host "❌ Exe file not found: $exePath"
          }

      - name: Upload artifacts to release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAG: ${{ inputs.tag }}
          REPO: ${{ github.repository }}
        shell: bash
        run: |
          echo "=== Starting upload process for tag: $TAG ==="
          BUNDLE_DIR="src-tauri/target/${{ matrix.target }}/release/bundle"

          if [ ! -d "$BUNDLE_DIR" ]; then
            echo "❌ Bundle directory not found: $BUNDLE_DIR"
            exit 1
          fi

          find "$BUNDLE_DIR" -type f \( \
            -name "*.msi" -o -name "*.exe" -o -name "*.zip" -o \
            -name "*.deb" -o \
            -name "*.sig" -o -name "*.dmg" -o -name "*.app.tar.gz" \
          \) | while IFS= read -r file; do
            echo "Uploading: $file"
            gh release upload "$TAG" "$file" --clobber --repo "$REPO"
          done

  build-flatpak:
    needs: build
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/flathub-infra/flatpak-github-actions:gnome-48
      options: --privileged
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.ref != '' && inputs.ref || github.ref }}

      - name: Download .deb from Release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAG: ${{ inputs.tag }}
        run: |
          # Download the .deb package from the release
          gh release download "$TAG" \
            --pattern "*_amd64.deb" \
            --dir .github/flatpak \
            --repo "${{ github.repository }}" \
            --clobber
          
          # Rename to expected name for manifest source
          mv .github/flatpak/*_amd64.deb .github/flatpak/antigravity-agent.deb
          
          echo "Downloaded and renamed .deb:"
          ls -la .github/flatpak/

      - name: Build Flatpak
        run: |
          # 1. Setup Flathub remote
          flatpak remote-add --if-not-exists flathub https://dl.flathub.org/repo/flathub.flatpakrepo

          # 2. Install GNOME 48 runtime
          flatpak install -y flathub org.gnome.Sdk//48 || true
          flatpak install -y flathub org.gnome.Platform//48 || true

          # 3. Build Flatpak
          flatpak-builder \
            --force-clean \
            --disable-rofiles-fuse \
            --repo=repo \
            --install-deps-from=flathub \
            build-dir \
            .github/flatpak/com.antigravity_agent.app.yml
          
          # 4. Create bundle with temp name
          flatpak build-bundle repo antigravity-agent.flatpak com.antigravity_agent.app

      - name: Rename Flatpak Bundle
        env:
          VERSION: ${{ inputs.version }}
          TAG: ${{ inputs.tag }}
        run: |
          # If version is provided, use it. Otherwise try to infer or fallback.
          FINAL_VERSION="${VERSION}"
          
          if [ -z "$FINAL_VERSION" ]; then
             # If no version input (e.g. autobuild scenario where inputs.version might be empty?), 
             # we might need a fallback or use the Tag if it looks like a version.
             # But for autobuild, the inputs.version is strictly optional.
             # However, autobuild.yml calls tauri-build without 'version' input in previous state.
             # Let's check autobuild.yml behavior. Autobuild tag name is 'autobuild'.
             # If we don't have version, we can name it 'antigravity-agent_nightly_amd64.flatpak' or similar.
             # But wait, logic in Build job was: 
             # if [ -n "$VERSION" ]; then AG_LINUX_MID="_${VERSION}"; else AG_LINUX_MID=""; fi
             # That implies without version, it's just antigravity-agent_amd64.deb
             
             if [ "$TAG" = "autobuild" ]; then
                 FINAL_NAME="antigravity-agent_amd64.flatpak"
             else
                 # Fallback if somehow version is missing but it's not autobuild (unlikely)
                 FINAL_NAME="antigravity-agent_amd64.flatpak"
             fi
          else
             FINAL_NAME="antigravity-agent_${FINAL_VERSION}_amd64.flatpak"
          fi
          
          mv antigravity-agent.flatpak "$FINAL_NAME"
          echo "FINAL_FLATPAK_NAME=$FINAL_NAME" >> $GITHUB_ENV
      
      - name: Upload Flatpak to Release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAG: ${{ inputs.tag }}
        run: |
          gh release upload "$TAG" "${{ env.FINAL_FLATPAK_NAME }}" --clobber --repo "${{ github.repository }}"
